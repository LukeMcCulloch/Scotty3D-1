

   //-----------------------------------------------------
	// collect elements
	//
	// halfedges
	// HalfedgeIter h0 = e0->halfedge();
	// HalfedgeIter h1 = h0->next(); // h1=h0->twin() below
	// HalfedgeIter h2 = h1->next();
	// HalfedgeIter h3 = h0->twin(); // 
	// HalfedgeIter h4 = h3->next();
	// HalfedgeIter h5 = h4->next();
	// HalfedgeIter h6 = h1->twin();
	// HalfedgeIter h7 = h2->twin();
	// HalfedgeIter h8 = h4->twin();
	// HalfedgeIter h9 = h5->twin();
	// //
	// // vertices (always pull from the interior)
	// VertexIter v0 = h0->vertex();
	// VertexIter v1 = h3->vertex();
	// VertexIter v2 = h2->vertex();
	// VertexIter v3 = h5->vertex();
	// //
	// // edges
	// //e0 = h0->edge(); passed in.  do not redeclare
	// EdgeIter e1 = h1->edge();
	// EdgeIter e2 = h2->edge();
	// EdgeIter e3 = h4->edge();
	// EdgeIter e4 = h5->edge();
	// //
	// // faces (pick the only unambiguous elements)
	// FaceIter f0 = h0->face();
	// FaceIter f1 = h3->face();

   if (e0->isBoundary() && e0->halfedge()->face()->degree() != 3)  {return e0->halfedge()->vertex(); }
	else if (e0->isBoundary() && e0->halfedge()->face()->degree() == 3) {
		HalfedgeIter h0 = e0->halfedge();
		HalfedgeIter h1 = h0->twin();

		//1 new vertex
		VertexIter v4 = newVertex();
		v4->position = e0->centroid();

		//1 new faces due to boundary
		FaceIter fnew = newFace();

		//2 new edges due to boundary
      EdgeIter e5 = newEdge();
      EdgeIter e6 = newEdge();	

		//4 new halfedges due to boundary
      HalfedgeIter h10 = newHalfedge();
      HalfedgeIter h11 = newHalfedge();
      HalfedgeIter h12 = newHalfedge();
      HalfedgeIter h13 = newHalfedge();

		//get old halfedges,faces and vertices
		HalfedgeIter h2 = h0->next();
		HalfedgeIter h3 = h2->next();

		FaceIter f0 = h0->face();

		VertexIter v0 = h0->vertex();
		VertexIter v1 = h2->vertex();
		VertexIter v2 = h3->vertex();
		//cout << "e0: " << &e0 << endl;
		//cout << "h: " << &(e0->halfedge()) << endl;
		//cout << "v0: " << &(h0->vertex()) << endl;
		//cout << "v1: " << &(h2->vertex()) << endl;
		//cout << "v2: " << &(h3->vertex()) << endl;
		//cout << "f0: " << &(h0->face()) << endl;
		//cout << "ho->face: " << &(h1->face()) << endl;

		//assign value to new elems
		v4->halfedge() = h0;
		e5->halfedge() = h10;
		e6->halfedge() = h12;
		fnew->halfedge() = h3;
		h10->setNeighbors(h3, h11, v4, e5, fnew);
		h11->setNeighbors(h0, h10, v2, e5, f0);
		h12->setNeighbors(h10, h13, v0, e6, fnew);
		h13->setNeighbors(h1->next(), h12, v4, e6, h1->face());

		//reassign old value
		e0->halfedge() = h0;
		f0->halfedge() = h2;
		h0->setNeighbors(h2, h1, v4, e0, f0);
		h1->setNeighbors(h13, h0, v1, e0, h1->face());
		h2->next() = h11;
		h2->face() = f0;
		h3->next() = h12;
		h3->face() = fnew;
		
		return v4;
	}

	if (e0->halfedge()->face()->degree() != 3 && e0->halfedge()->twin()->face()->degree() != 3) {
		return e0->halfedge()->vertex();
	}


   //
   //---------------------------------
   //
   // now we are on a standard face 

	HalfedgeIter h0 = e0->halfedge();
	HalfedgeIter h1 = h0->twin();

	//initialize new vertex
	VertexIter v4 = newVertex();
	v4->position = e0->centroid();

	//initialize new edge, face and halfedge
	//3 new edges 
	EdgeIter e5 = newEdge();
	EdgeIter e6 = newEdge();
	EdgeIter e7 = newEdge();

	//2 new faces (we already had 2)
	FaceIter f2 = newFace();
   FaceIter f3 = newFace();

	//6 new halfedges (2 for each new edge)
   HalfedgeIter h10 = newHalfedge();
   HalfedgeIter h11 = newHalfedge();
   HalfedgeIter h12 = newHalfedge();
   HalfedgeIter h13 = newHalfedge();
   HalfedgeIter h14 = newHalfedge();
   HalfedgeIter h15 = newHalfedge();

	//get old halfedges,faces and vertices
	HalfedgeIter h2 = h0->next();
	HalfedgeIter h3 = h2->next();
	HalfedgeIter h4 = h1->next();
	HalfedgeIter h5 = h4->next();
	
	FaceIter f0 = h0->face();
	FaceIter f1 = h1->face();

	VertexIter v0 = h0->vertex();
	VertexIter v1 = h5->vertex();
	VertexIter v2 = h1->vertex();
	VertexIter v3 = h3->vertex();

	//assign value to new elems
	v4->halfedge() = h0;
	e5->halfedge() = h11;
	e6->halfedge() = h13;
	e7->halfedge() = h15;
	f2->halfedge() = h4;
	f3->halfedge() = h3;

	h10->setNeighbors(h0, h15, v3, e7, f0);
	h11->setNeighbors(h5, h12, v4, e5, f1);
	h12->setNeighbors(h13, h11, v1, e5, f2);
	h13->setNeighbors(h4, h14, v4, e6, f2);
	h14->setNeighbors(h15, h13, v0, e6, f3);
	h15->setNeighbors(h3, h10, v4, e7, f3);

	//reassign value to old elements
	e0->halfedge() = h0;
	f0->halfedge() = h2;
	f1->halfedge() = h5;
	h0->setNeighbors(h2, h1, v4, e0, f0);
	h1->setNeighbors(h11, h0, v2, e0, f1);
	h2->next() = h10;
	h2->face() = f0;
	h3->next() = h14;
	h3->face() = f3;
	h4->next() = h12;
	h4->face() = f2;
	h5->next() = h1;
	h5->face() = f1;
	
	return v4;
}





// EdgeIter HalfedgeMesh::flipEdge(EdgeIter e0) {
//   // TODO: (meshEdit)
//   // This method should flip the given edge and return an iterator to the
//   // flipped edge.

//   // Note: This does a complete reassignment of references, which will likely include
//   // changing things that don't technically need to be changed (like anyHalfEdge refs
//   // that weren't actually invalidated). This is done for simplicity and conciseness.

//   //
//   // NOTE: for tris only
//   //

//   // There is a guide for this code 
//   //  todo: point at it here
//   /*
// 	GUIDE TO IMPLEMENTING EDGE OPERATIONS
// 	ON A HALFEDGE DATA STRUCTURE
// 	CMU CS 15-462 (FALL 2015)
//   */

// 	if (e0->isBoundary()) {
// 		return e0;
// 	}

// 	HalfedgeIter h = e0->halfedge();
// 	HalfedgeIter h2 = h->twin();
// 	HalfedgeIter h1 = h;
// 	while (h1->next() != h) {
// 		h1 = h1->next();
// 	}
// 	HalfedgeIter hn = h->next();
// 	HalfedgeIter hnn = hn->next();
// 	HalfedgeIter h2n = h2->next();
// 	HalfedgeIter h2nn = h2n->next();
// 	HalfedgeIter h6 = h2;
// 	while (h6->next() != h2) {
// 		h6 = h6->next();
// 	}

// 	VertexIter v0 = h->vertex();
// 	VertexIter v1 = h2nn->vertex();
// 	VertexIter v2 = h2->vertex();
// 	VertexIter v3 = hnn->vertex();

// 	FaceIter f0 = h->face();
// 	FaceIter f1 = h2->face();

// 	h1->next() = h2n;
// 	h2n->next() = h;
// 	h->next() = hnn;
// 	h6->next() = hn;
// 	hn->next() = h2;
// 	h2->next() = h2nn;

// 	h->vertex() = v1;
// 	h2->vertex() = v3;

// 	h2n->face() = f0;
// 	hn->face() = f1;

// 	h->edge() = e0;
// 	h2->edge() = e0;

// 	h->twin() = h2;
// 	h2->twin() = h;

// 	//update the vertex
// 	v0->halfedge() = h2n;
// 	v1->halfedge() = h2nn;
// 	v2->halfedge() = hn;
// 	v3->halfedge() = hnn;

// 	//update the face
// 	f0->halfedge() = h;
// 	f1->halfedge() = h2;

// 	e0->halfedge() = h;

//   return e0;
// }